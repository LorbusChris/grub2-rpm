From d1224d209be3fcfa5cea7b3e637cfc429f7d2345 Mon Sep 17 00:00:00 2001
From: Vladimir Serbinenko <phcoder@gmail.com>
Date: Sun, 10 Aug 2014 11:27:36 +0200
Subject: [PATCH 092/506] 	* grub-core/kern/disk_common.c: Clump disk
 size to 1EiB.

---
 ChangeLog                    |  4 ++++
 grub-core/kern/disk_common.c | 22 ++++++++++++++++------
 2 files changed, 20 insertions(+), 6 deletions(-)

diff --git a/ChangeLog b/ChangeLog
index 9e159a8..6c389b0 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,5 +1,9 @@
 2014-08-10  Vladimir Serbinenko  <phcoder@gmail.com>
 
+	* grub-core/kern/disk_common.c: Clump disk size to 1EiB.
+
+2014-08-10  Vladimir Serbinenko  <phcoder@gmail.com>
+
 	* grub-core/disk/i386/pc/biosdisk.c (grub_biosdisk_rw): Add
 	safety to avoid triggerring VirtualBox bug.
 
diff --git a/grub-core/kern/disk_common.c b/grub-core/kern/disk_common.c
index fb19778..2ca12b5 100644
--- a/grub-core/kern/disk_common.c
+++ b/grub-core/kern/disk_common.c
@@ -7,6 +7,8 @@ grub_disk_adjust_range (grub_disk_t disk, grub_disk_addr_t *sector,
 			grub_off_t *offset, grub_size_t size)
 {
   grub_partition_t part;
+  grub_disk_addr_t total_sectors;
+
   *sector += *offset >> GRUB_DISK_SECTOR_BITS;
   *offset &= GRUB_DISK_SECTOR_SIZE - 1;
 
@@ -27,12 +29,20 @@ grub_disk_adjust_range (grub_disk_t disk, grub_disk_addr_t *sector,
       *sector += start;
     }
 
-  if (disk->total_sectors != GRUB_DISK_SIZE_UNKNOWN
-      && ((disk->total_sectors << (disk->log_sector_size - GRUB_DISK_SECTOR_BITS)) <= *sector
-	  || ((*offset + size + GRUB_DISK_SECTOR_SIZE - 1)
-	  >> GRUB_DISK_SECTOR_BITS) > (disk->total_sectors
-				       << (disk->log_sector_size
-					   - GRUB_DISK_SECTOR_BITS)) - *sector))
+  /* Transform total_sectors to number of 512B blocks.  */
+  total_sectors = disk->total_sectors << (disk->log_sector_size - GRUB_DISK_SECTOR_BITS);
+
+  /* Some drivers have problems with disks above reasonable.
+     Treat unknown as 1EiB disk. While on it, clamp the size to 1EiB.
+     Just one condition is enough since GRUB_DISK_UNKNOWN_SIZE << ls is always
+     above 9EiB.
+  */
+  if (total_sectors > (1ULL << 51))
+    total_sectors = (1ULL << 51);
+
+  if ((total_sectors <= *sector
+       || ((*offset + size + GRUB_DISK_SECTOR_SIZE - 1)
+	   >> GRUB_DISK_SECTOR_BITS) > total_sectors - *sector))
     return grub_error (GRUB_ERR_OUT_OF_RANGE,
 		       N_("attempt to read or write outside of disk `%s'"), disk->name);
 
-- 
2.4.3

