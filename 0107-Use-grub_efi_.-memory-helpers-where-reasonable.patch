From f94d8ef23f942bcb5c156a11da54bff9cb672c60 Mon Sep 17 00:00:00 2001
From: Peter Jones <pjones@redhat.com>
Date: Thu, 1 Jun 2017 10:06:38 -0400
Subject: [PATCH 107/225] Use grub_efi_...() memory helpers where reasonable.

This uses grub_efi_allocate_pool(), grub_efi_free_pool(),
grub_efi_free_pages(), and grub_efi_allocate_pages_real() instead of
open-coded efi_call_N() calls, so we get more reasonable type checking.

Signed-off-by: Peter Jones <pjones@redhat.com>
---
 grub-core/kern/efi/mm.c            | 11 +++--------
 grub-core/lib/efi/relocator.c      |  9 ++++-----
 grub-core/loader/efi/chainloader.c | 12 ++++++------
 grub-core/mmap/efi/mmap.c          | 26 +++++++++-----------------
 4 files changed, 22 insertions(+), 36 deletions(-)

diff --git a/grub-core/kern/efi/mm.c b/grub-core/kern/efi/mm.c
index 1ef5a42bf..75d934457 100644
--- a/grub-core/kern/efi/mm.c
+++ b/grub-core/kern/efi/mm.c
@@ -69,10 +69,8 @@ grub_efi_store_alloc (grub_efi_physical_address_t address,
   struct efi_allocation *alloc;
   grub_efi_status_t status;
 
-  b = grub_efi_system_table->boot_services;
-  status = efi_call_3 (b->allocate_pool, GRUB_EFI_LOADER_DATA,
-                           sizeof(*alloc), (void**)&alloc);
-
+  status = grub_efi_allocate_pool (GRUB_EFI_LOADER_DATA,
+				   sizeof(*alloc), (void**)&alloc);
   if (status == GRUB_EFI_SUCCESS)
     {
       alloc->next = efi_allocated_memory;
@@ -90,9 +88,6 @@ grub_efi_drop_alloc (grub_efi_physical_address_t address,
                            grub_efi_uintn_t pages)
 {
   struct efi_allocation *ea, *eap;
-  grub_efi_boot_services_t *b;
-
-  b = grub_efi_system_table->boot_services;
 
   for (eap = NULL, ea = efi_allocated_memory; ea; eap = ea, ea = ea->next)
     {
@@ -106,7 +101,7 @@ grub_efi_drop_alloc (grub_efi_physical_address_t address,
         efi_allocated_memory = ea->next;
 
       /* Then free the memory backing it. */
-      efi_call_1 (b->free_pool, ea);
+      grub_efi_free_pool (ea);
 
       /* And leave, we're done. */
       break;
diff --git a/grub-core/lib/efi/relocator.c b/grub-core/lib/efi/relocator.c
index 319b69eeb..c4cd456ad 100644
--- a/grub-core/lib/efi/relocator.c
+++ b/grub-core/lib/efi/relocator.c
@@ -90,7 +90,6 @@ grub_relocator_firmware_fill_events (struct grub_relocator_mmap_event *events)
 int
 grub_relocator_firmware_alloc_region (grub_addr_t start, grub_size_t size)
 {
-  grub_efi_boot_services_t *b;
   grub_efi_physical_address_t address = start;
   grub_efi_status_t status;
 
@@ -100,9 +99,9 @@ grub_relocator_firmware_alloc_region (grub_addr_t start, grub_size_t size)
   grub_dprintf ("relocator", "EFI alloc: %llx, %llx\n",
 		(unsigned long long) start, (unsigned long long) size);
 #endif
-  b = grub_efi_system_table->boot_services;
-  status = efi_call_4 (b->allocate_pages, GRUB_EFI_ALLOCATE_ADDRESS,
-		       GRUB_EFI_LOADER_DATA, size >> 12, &address);
+  status = grub_efi_allocate_pages_real (GRUB_EFI_ALLOCATE_ADDRESS,
+					 GRUB_EFI_LOADER_DATA,
+					 size >> 12, &address);
   return (status == GRUB_EFI_SUCCESS);
 }
 
@@ -115,5 +114,5 @@ grub_relocator_firmware_free_region (grub_addr_t start, grub_size_t size)
     return;
 
   b = grub_efi_system_table->boot_services;
-  efi_call_2 (b->free_pages, start, size >> 12);
+  grub_efi_free_pages (start, size >> 12);
 }
diff --git a/grub-core/loader/efi/chainloader.c b/grub-core/loader/efi/chainloader.c
index adc856366..c5f08f03f 100644
--- a/grub-core/loader/efi/chainloader.c
+++ b/grub-core/loader/efi/chainloader.c
@@ -57,7 +57,7 @@ grub_chainloader_unload (void)
 
   b = grub_efi_system_table->boot_services;
   efi_call_1 (b->unload_image, image_handle);
-  efi_call_2 (b->free_pages, address, pages);
+  grub_efi_free_pages (address, pages);
 
   grub_free (file_path);
   grub_free (cmdline);
@@ -99,7 +99,7 @@ grub_chainloader_boot (void)
     }
 
   if (exit_data)
-    efi_call_1 (b->free_pool, exit_data);
+    grub_efi_free_pool (exit_data);
 
   grub_loader_unset ();
 
@@ -273,9 +273,9 @@ grub_cmd_chainloader (grub_command_t cmd __attribute__ ((unused)),
     }
   pages = (((grub_efi_uintn_t) size + ((1 << 12) - 1)) >> 12);
 
-  status = efi_call_4 (b->allocate_pages, GRUB_EFI_ALLOCATE_ANY_PAGES,
-			      GRUB_EFI_LOADER_CODE,
-			      pages, &address);
+  status = grub_efi_allocate_pages_real (GRUB_EFI_ALLOCATE_ANY_PAGES,
+					 GRUB_EFI_LOADER_CODE,
+					 pages, &address);
   if (status != GRUB_EFI_SUCCESS)
     {
       grub_dprintf ("chain", "Failed to allocate %u pages\n",
@@ -400,7 +400,7 @@ grub_cmd_chainloader (grub_command_t cmd __attribute__ ((unused)),
   grub_free (file_path);
 
   if (address)
-    efi_call_2 (b->free_pages, address, pages);
+    grub_efi_free_pages (address, pages);
 
   grub_dl_unref (my_mod);
 
diff --git a/grub-core/mmap/efi/mmap.c b/grub-core/mmap/efi/mmap.c
index bd495a184..d103c5e01 100644
--- a/grub-core/mmap/efi/mmap.c
+++ b/grub-core/mmap/efi/mmap.c
@@ -191,7 +191,6 @@ grub_mmap_register (grub_uint64_t start, grub_uint64_t size, int type)
 {
   grub_uint64_t end = start + size;
   grub_efi_physical_address_t address;
-  grub_efi_boot_services_t *b;
   grub_efi_uintn_t pages;
   grub_efi_status_t status;
   struct overlay *curover;
@@ -200,17 +199,17 @@ grub_mmap_register (grub_uint64_t start, grub_uint64_t size, int type)
   if (! curover)
     return 0;
 
-  b = grub_efi_system_table->boot_services;
   address = start & (~0xfffULL);
   pages = (end - address + 0xfff) >> 12;
-  status = efi_call_2 (b->free_pages, address, pages);
+  status = grub_efi_free_pages (address, pages);
   if (status != GRUB_EFI_SUCCESS && status != GRUB_EFI_NOT_FOUND)
     {
       grub_free (curover);
       return 0;
     }
-  status = efi_call_4 (b->allocate_pages, GRUB_EFI_ALLOCATE_ADDRESS,
-		       make_efi_memtype (type), pages, &address);
+  status = grub_efi_allocate_pages_real (GRUB_EFI_ALLOCATE_ADDRESS,
+					 make_efi_memtype (type),
+					 pages, &address);
   if (status != GRUB_EFI_SUCCESS)
     {
       grub_free (curover);
@@ -229,17 +228,13 @@ grub_err_t
 grub_mmap_unregister (int handle)
 {
   struct overlay *curover, *prevover;
-  grub_efi_boot_services_t *b;
-
-  b = grub_efi_system_table->boot_services;
-
 
   for (curover = overlays, prevover = 0; curover;
        prevover = curover, curover = curover->next)
     {
       if (curover->handle == handle)
 	{
-	  efi_call_2 (b->free_pages, curover->address, curover->pages);
+	  grub_efi_free_pages (curover->address, curover->pages);
 	  if (prevover != 0)
 	    prevover->next = curover->next;
 	  else
@@ -259,7 +254,6 @@ grub_mmap_malign_and_register (grub_uint64_t align __attribute__ ((unused)),
 			       int flags __attribute__ ((unused)))
 {
   grub_efi_physical_address_t address;
-  grub_efi_boot_services_t *b;
   grub_efi_uintn_t pages;
   grub_efi_status_t status;
   struct overlay *curover;
@@ -269,8 +263,6 @@ grub_mmap_malign_and_register (grub_uint64_t align __attribute__ ((unused)),
   if (! curover)
     return 0;
 
-  b = grub_efi_system_table->boot_services;
-
   address = 0xffffffff;
 
 #if GRUB_TARGET_SIZEOF_VOID_P < 8
@@ -281,8 +273,8 @@ grub_mmap_malign_and_register (grub_uint64_t align __attribute__ ((unused)),
 #endif
 
   pages = (size + 0xfff) >> 12;
-  status = efi_call_4 (b->allocate_pages, atype,
-		       make_efi_memtype (type), pages, &address);
+  status = grub_efi_allocate_pages_real (atype, make_efi_memtype (type),
+					 pages, &address);
   if (status != GRUB_EFI_SUCCESS)
     {
       grub_free (curover);
@@ -294,8 +286,8 @@ grub_mmap_malign_and_register (grub_uint64_t align __attribute__ ((unused)),
       /* Uggh, the address 0 was allocated... This is too annoying,
 	 so reallocate another one.  */
       address = 0xffffffff;
-      status = efi_call_4 (b->allocate_pages, atype,
-			   make_efi_memtype (type), pages, &address);
+      status = grub_efi_allocate_pages_real (atype, make_efi_memtype (type),
+					     pages, &address);
       grub_efi_free_pages (0, pages);
       if (status != GRUB_EFI_SUCCESS)
 	return 0;
-- 
2.14.3

